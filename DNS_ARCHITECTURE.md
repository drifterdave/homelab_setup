# DNS Architecture

## DNS Zone Management

### Zone Configuration
DNS zones are configured in `dns.auto.tfvars` file for easy management without 1Password complexity.

### DNS Zone Configuration Structure
```hcl
# dns.auto.tfvars
dns = {
  "excloo.com" = [
    {
      content  = "hsp.au.excloo.net"
      name     = "@"
      proxied  = true      # Optional, defaults to false
      type     = "CNAME"
      wildcard = true      # Optional, creates *.domain.com
    },
    {
      content  = "in1-smtp.messagingengine.com"
      name     = "@"
      priority = 10
      type     = "MX"
    },
    {
      content = "v=spf1 include:spf.messagingengine.com ?all"
      name    = "@"
      type    = "TXT"
    }
    # ... more records
  ]
}
```

## DNS Record Management Strategy

### Automatic DNS Records (Generated by OpenTofu)

1. **Server DNS Records**
   - External: `server.region.excloo.net` → Public IP
   - Internal: `server.region.excloo.dev` → Tailscale IP
   - Example: `hsp.au.excloo.net`, `hsp.au.excloo.dev`

2. **Service DNS Records**
   - From Website fields in service entries
   - External (`.net`): Points to server or Cloudflare proxy
   - Internal (`.dev`): Points to Tailscale IP
   - Wildcards: `*.server.region.domain` for catch-all

3. **Router/Infrastructure DNS**
   - Region-based: `au.excloo.net` → Router public IP
   - Used as base for CNAME records

### Manual DNS Records (From dns.auto.tfvars)

Manual records defined in the `dns` variable are created as-is. This handles:
- MX records for email
- TXT records for verification (SPF, DKIM, domain verification)
- CNAME records for external services
- Special A/AAAA records
- Wildcard records (when `wildcard = true`)

### DNS Patterns

```hcl
# Auto-generated patterns
locals {
  dns_patterns = {
    # Server DNS
    server_external = "${server.name}.${server.region}.${external_domain}"
    server_internal = "${server.name}.${server.region}.${internal_domain}"
    
    # Service DNS (from Website fields)
    service_primary = "from Website field if domain matches zone"
    service_internal = "from Website 2 field if .dev domain"
    service_redirects = "from Website 3+ fields"
    
    # Wildcard for services
    wildcard_internal = "*.${server.name}.${server.region}.${internal_domain}"
  }
}
```

## Implementation

### File Structure
- `cloudflare.tf` - Cloudflare zone data sources and DNS record resources
- `locals_dns.tf` - All DNS record generation logic:
  - Homelab DNS records (from 1Password entries)
  - Manual DNS records (from dns variable)
  - ACME challenge records (for SSL certificates)
  - Wildcard records

### Zone Definition
```hcl
# variables.tf
variable "dns" {
  description = "DNS records by zone"
  type = map(list(object({
    content  = string
    name     = string
    type     = string
    priority = optional(number)
    proxied  = optional(bool, false)    # Defaults to false
    wildcard = optional(bool, false)    # Creates additional *.name record
  })))
  default = {}
}

# cloudflare.tf
data "cloudflare_zone" "configured" {
  for_each = var.dns
  
  filter = {
    name = each.key
  }
}
```

### Record Processing
```hcl
# locals_dns.tf - All DNS record generation logic

locals {
  # Homelab DNS records (from 1Password entries)
  dns_records_homelab = merge(
    # External records (CNAME, A, AAAA)
    # Internal Tailscale records
    # Wildcard records for services
    # ACME challenge records
  )
  
  # Manual DNS records (from dns variable)
  dns_records_manual = merge(
    # Direct records from configuration
    # Wildcard records when wildcard = true
    # ACME challenge records for SSL
  )
}

# cloudflare.tf - DNS resource creation
resource "cloudflare_dns_record" "all" {
  for_each = nonsensitive(merge(
    local.dns_records_homelab,
    local.dns_records_manual
  ))
  
  comment  = "OpenTofu Managed"
  content  = each.value.content
  name     = each.value.name
  priority = try(each.value.priority, null)
  proxied  = try(each.value.proxied, false)
  ttl      = 1
  type     = each.value.type
  zone_id  = each.value.zone_id
}
```

### ACME Challenge Records
ACME challenges are automatically generated for SSL certificate validation:
- Generated for all homelab entries with public or Tailscale IPs
- Generated for all manual A, AAAA, and CNAME records
- Points to centralized ACME challenge domain for validation
- Pattern: `_acme-challenge.subdomain` → `_acme-challenge.${domain_acme}`

## Best Practices

1. **Zone Organization**
   - All zones defined in `dns.auto.tfvars`
   - Simple structure: zone → list of records
   - No redundant configuration (if it's in the config, it's managed)

2. **Record Management**
   - Infrastructure DNS: Auto-generated from servers/services
   - Application DNS: From Website fields in service entries
   - Special records: In `dns.auto.tfvars` records array

3. **Proxy Settings**
   - Default: `proxied = false` (safer default)
   - Explicitly set `proxied = true` for records that need Cloudflare proxy
   - Wildcards cannot be proxied

4. **SSL Certificates**
   - External (proxied): Cloudflare manages certificates
   - External (direct): Caddy with Let's Encrypt
   - Internal: Caddy with Cloudflare DNS validation

## Record Types

### Standard Records
```hcl
# A/AAAA Records
{
  content = "192.168.1.1"
  name    = "server"
  type    = "A"
}

# CNAME Records
{
  content = "target.example.com"
  name    = "alias"
  type    = "CNAME"
  proxied = true  # Enable Cloudflare proxy
}

# MX Records
{
  content  = "mail.example.com"
  name     = "@"
  priority = 10
  type     = "MX"
}

# TXT Records
{
  content = "v=spf1 include:example.com ~all"
  name    = "@"
  type    = "TXT"
}
```

### Wildcard Records
```hcl
# Root wildcard (*.example.com → example.com)
{
  content  = "target.example.com"
  name     = "@"
  type     = "CNAME"
  wildcard = true  # Creates * → example.com
}

# Subdomain wildcard (*.sub.example.com → sub.example.com)
{
  content  = "target.example.com"
  name     = "sub"
  type     = "CNAME"
  wildcard = true  # Creates *.sub → sub.example.com
}
```

## Advantages

1. **Simplicity**
   - All DNS configuration in one file
   - No redundant fields (enabled, proxied_default)
   - Easy to edit and version control

2. **Flexibility**
   - Per-record proxy control
   - Automatic wildcard generation
   - Zone-level organization

3. **Version Control**
   - All DNS changes tracked in Git
   - Clear separation between manual and automatic records
   - Easy to review changes in pull requests

4. **Safety**
   - Conservative defaults (proxied = false)
   - Explicit configuration required for proxying
   - Prevents accidental misconfiguration