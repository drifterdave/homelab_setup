# DNS Architecture

## DNS Zone Management

### Zone Configuration
DNS zones are configured in `infrastructure/dns.auto.tfvars` file for easy management without 1Password complexity.

### DNS Zone Configuration Structure
```hcl
# infrastructure/dns.auto.tfvars
dns = {
  "excloo.com" = [
    {
      content  = "hsp.au.excloo.net"
      name     = "@"
      proxied  = true      # Optional, defaults to false
      type     = "CNAME"
      wildcard = true      # Optional, creates *.domain.com
    },
    {
      content  = "in1-smtp.messagingengine.com"
      name     = "@"
      priority = 10
      type     = "MX"
    },
    {
      content = "v=spf1 include:spf.messagingengine.com ?all"
      name    = "@"
      type    = "TXT"
    }
    # ... more records
  ]
}
```

## DNS Record Management Strategy

### Automatic DNS Records (Generated by OpenTofu)

1. **Server DNS Records**
   - External: `server.region.excloo.net` → Public IP
   - Internal: `server.region.excloo.dev` → Tailscale IP
   - Example: `hsp.au.excloo.net`, `hsp.au.excloo.dev`

2. **Service DNS Records**
   - From Website fields in service entries
   - External (`.net`): Points to server or Cloudflare proxy
   - Internal (`.dev`): Points to Tailscale IP
   - Wildcards: `*.server.region.domain` for catch-all

3. **Router/Infrastructure DNS**
   - Region-based: `au.excloo.net` → Router public IP
   - Used as base for CNAME records

### Manual DNS Records (From dns.auto.tfvars)

Manual records defined in the `dns` variable are created as-is. This handles:
- MX records for email
- TXT records for verification (SPF, DKIM, domain verification)
- CNAME records for external services
- Special A/AAAA records
- Wildcard records (when `wildcard = true`)

### DNS Patterns

```hcl
# Auto-generated patterns
locals {
  dns_patterns = {
    # Server DNS
    server_external = "${server.name}.${server.region}.${external_domain}"
    server_internal = "${server.name}.${server.region}.${internal_domain}"
    
    # Service DNS (from Website fields)
    service_primary = "from Website field if domain matches zone"
    service_internal = "from Website 2 field if .dev domain"
    service_redirects = "from Website 3+ fields"
    
    # Wildcard for services
    wildcard_internal = "*.${server.name}.${server.region}.${internal_domain}"
  }
}
```

## Implementation

### Zone Definition
```hcl
# infrastructure/dns.tf
variable "dns" {
  description = "DNS records by zone"
  type = map(list(object({
    content  = string
    name     = string
    type     = string
    priority = optional(number)
    proxied  = optional(bool, false)    # Defaults to false
    wildcard = optional(bool, false)    # Creates additional *.name record
  })))
  default = {}
}

# Get Cloudflare zones
data "cloudflare_zones" "configured" {
  for_each = var.dns
  
  filter {
    name       = each.key
    account_id = local.providers.cloudflare.account_id
  }
}
```

### Record Processing
```hcl
# Merge automatic and manual records
locals {
  all_dns_records = merge(
    local.manual_dns_records,    # From dns.auto.tfvars
    local.wildcard_dns_records,  # Auto-generated wildcards
    local.server_dns_records,    # Auto-generated
    local.service_dns_records    # From service websites
  )
  
  manual_dns_records = merge([
    for zone_name, records in var.dns : {
      for idx, record in records : 
      "${zone_name}-manual-${record.type}-${idx}" => {
        zone_id  = data.cloudflare_zones.configured[zone_name].zones[0].id
        name     = record.name
        type     = record.type
        value    = record.type == "MX" ? "${record.priority} ${record.content}" : record.content
        priority = record.type == "MX" ? record.priority : null
        proxied  = record.proxied
      }
    }
  ]...)
  
  # Wildcard records (when wildcard = true on CNAME records)
  wildcard_dns_records = merge([
    for zone_name, records in var.dns : {
      for idx, record in records :
      "${zone_name}-wildcard-${idx}" => {
        zone_id  = data.cloudflare_zones.configured[zone_name].zones[0].id
        name     = record.name == "@" ? "*" : "*.${record.name}"
        type     = "CNAME"
        value    = record.name == "@" ? zone_name : "${record.name}.${zone_name}"
        priority = null
        proxied  = false  # Wildcards can't be proxied
      } if record.wildcard && record.type == "CNAME"
    }
  ]...)
}
```

## Best Practices

1. **Zone Organization**
   - All zones defined in `infrastructure/dns.auto.tfvars`
   - Simple structure: zone → list of records
   - No redundant configuration (if it's in the config, it's managed)

2. **Record Management**
   - Infrastructure DNS: Auto-generated from servers/services
   - Application DNS: From Website fields in service entries
   - Special records: In `dns.auto.tfvars` records array

3. **Proxy Settings**
   - Default: `proxied = false` (safer default)
   - Explicitly set `proxied = true` for records that need Cloudflare proxy
   - Wildcards cannot be proxied

4. **SSL Certificates**
   - External (proxied): Cloudflare manages certificates
   - External (direct): Caddy with Let's Encrypt
   - Internal: Caddy with Cloudflare DNS validation

## Record Types

### Standard Records
```hcl
# A/AAAA Records
{
  content = "192.168.1.1"
  name    = "server"
  type    = "A"
}

# CNAME Records
{
  content = "target.example.com"
  name    = "alias"
  type    = "CNAME"
  proxied = true  # Enable Cloudflare proxy
}

# MX Records
{
  content  = "mail.example.com"
  name     = "@"
  priority = 10
  type     = "MX"
}

# TXT Records
{
  content = "v=spf1 include:example.com ~all"
  name    = "@"
  type    = "TXT"
}
```

### Wildcard Records
```hcl
# Root wildcard (*.example.com → example.com)
{
  content  = "target.example.com"
  name     = "@"
  type     = "CNAME"
  wildcard = true  # Creates * → example.com
}

# Subdomain wildcard (*.sub.example.com → sub.example.com)
{
  content  = "target.example.com"
  name     = "sub"
  type     = "CNAME"
  wildcard = true  # Creates *.sub → sub.example.com
}
```

## Advantages

1. **Simplicity**
   - All DNS configuration in one file
   - No redundant fields (enabled, proxied_default)
   - Easy to edit and version control

2. **Flexibility**
   - Per-record proxy control
   - Automatic wildcard generation
   - Zone-level organization

3. **Version Control**
   - All DNS changes tracked in Git
   - Clear separation between manual and automatic records
   - Easy to review changes in pull requests

4. **Safety**
   - Conservative defaults (proxied = false)
   - Explicit configuration required for proxying
   - Prevents accidental misconfiguration